<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Required meta tags -->
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- FontAwesome -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">

  <!-- Google fonts -->
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800&family=Poppins:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">


  <!-- Stylesheets -->
  <link rel="stylesheet" href="css/vendors.css">
  <link rel="stylesheet" href="css/main.css">

  <!-- Favicon -->


  <title>Loaded</title>
</head>

<body class="" data-barba="wrapper">
  <div data-scroll-container>
    <main data-barba="container" data-barba-namespace="base">


      <header class="header js-header">
        <div class="container relative">
          <div class="row justify-content-between align-items-center">
            <div class="col-auto">
              <a href="index.html" class="header__logo">
                <!-- <img src="#" alt="site logo"> -->
                LOADED
              </a>
            </div>

            <div class="col-auto">
              <div class="header__menu">
                <button class="header__button -open js-nav-open">
                  Menu
                  <div class="header__button__open__bars">
                    <span></span>
                    <span></span>
                    <span></span>
                  </div>
                </button>

                <button class="header__button -close pointer-events-none js-nav-close">
                  Close
                  <i class="icon" data-feather="x"></i>
                </button>
              </div>
            </div>
          </div>
        </div>

        <nav class="nav pointer-events-none js-nav">
          <div class="nav__bg js-nav-bg"></div>

          <div class="nav__list js-nav-list">
            <a href="index.html" class="nav__link">Home</a>
            <a href="about.html" class="nav__link">About</a>
            <a href="talents.html" class="nav__link">Talents</a>
          </div>
        </nav>
      </header>


      <section class="homeSection">
        <div class="container">
          <div class="row">
            <div class="col-12">
              <div class="homeSection__logo js-home">
                <img class="icon" src="img/home-logo.svg" alt="company logo">
              </div>
            </div>

            <div class="col-12">
              <div class="homeSection__text">
                <p>
                  It is a period of civil war. Rebel spaceships, striking from a hidden base, have won their first victory against the evil Galactic Empire. During the battle, Rebel spies managed to steal secret plans to the Empire's ultimate weapon, the Death Star, an armored space station with enough power to destroy an entire planet. Pursued by the Empire's sinister agents.
                </p>
              </div>
            </div>
          </div>
        </div>
      </section>


      <div id="container" class="container">
        <div class="row justify-content-center">
          <div class="col-lg-4">
            <div class="dist-item">
              <img src="img/ginger.jpg" class="js-image" alt="">
              <h2>Some title</h2>
              <p>Lorem ipsum.</p>
            </div>
          </div>
        </div>
      </div>


    </main>
  </div>


  <!-- GLSL -->
  <script id="shader-vertex" type="x-shader/x-vertex">
    #define PI 3.14159265359
    uniform float u_offset;
    uniform float u_progress;
    uniform float u_direction;
    uniform float u_time;
    uniform float u_waveIntensity;
    varying vec2 vUv;
    void main(){
        vec3 pos = position.xyz;

        float distance = length(uv.xy - 0.5 );
        float sizeDist = length(vec2(0.5,0.5));
        float normalizedDistance = distance/sizeDist ;

        float stickOutEffect = normalizedDistance ;
        float stickInEffect = -normalizedDistance ;

        
        float stickEffect = mix(stickOutEffect,stickInEffect, u_direction);

        // Backwards V wave.
        float stick = 0.5;

        float waveIn = u_progress*(1. / stick); 
        float waveOut =  -( u_progress - 1.) * (1./(1.-stick) );
        waveOut = pow(smoothstep(0.,1.,waveOut),0.7);

        float stickProgress = min(waveIn, waveOut);





        // We can re-use stick Influcse because this oen starts at the same position
        float offsetInProgress = clamp(waveIn,0.,1.);

        // Invert stickout to get the slope moving upwards to the right
        // and move it left by 1
        float offsetOutProgress = clamp(1.-waveOut,0.,1.);

        float offsetProgress = mix(offsetInProgress,offsetOutProgress,u_direction);


        float stickOffset = u_offset;
        pos.z += stickEffect * stickOffset * stickProgress  - u_offset * offsetProgress;

        
        pos.z += sin(distance * 8. - u_time * 2. )  * u_waveIntensity;

        gl_Position =   
            projectionMatrix * 
            modelViewMatrix * 
            vec4(pos, 1.0);

        vUv = uv;
    }
  </script>

  <script id="shader-fragment" type="x-shader/x-fragment">
    uniform vec2 u_resolution;

    uniform sampler2D u_texture;
    uniform sampler2D u_texture2;
    uniform vec2 u_textureFactor;
    uniform vec2 u_texture2Factor;
    uniform float u_textureProgress;

    // RGB
    uniform vec2 u_rgbPosition;
    uniform vec2 u_rgbVelocity;

    varying vec2 vUv;
    vec2 centeredAspectRatio(vec2 uvs, vec2 factor){
        return uvs * factor - factor /2. + 0.5;
    }
    void main(){
        // On THREE 102 The image is has Y backwards
        // vec2 flipedUV = vec2(vUv.x,1.-vUv.y);

        vec2 normalizedRgbPos = u_rgbPosition / u_resolution;
        normalizedRgbPos.y = 1. - normalizedRgbPos.y; 

        
        vec2 vel = u_rgbVelocity;
        float dist = distance(normalizedRgbPos + vel / u_resolution, vUv.xy);

        float ratio = clamp(1.0 - dist * 5., 0., 1.);


        vec4 tex1 = vec4(1.);
        vec4 tex2 = vec4(1.);

        vec2 uv = vUv;

        uv.x -= sin(uv.y) * ratio / 100. * (vel.x + vel.y) / 7.;
        uv.y -= sin(uv.x) * ratio / 100. * (vel.x + vel.y) / 7.;

        tex1.r = texture2D(u_texture, centeredAspectRatio(uv, u_textureFactor )).r;
        tex2.r = texture2D(u_texture2, centeredAspectRatio(uv, u_textureFactor )).r;

        
        uv.x -= sin(uv.y) * ratio / 150. * (vel.x + vel.y) / 7.;
        uv.y -= sin(uv.x) * ratio / 150. * (vel.x + vel.y) / 7.;

        tex1.g = texture2D(u_texture, centeredAspectRatio(uv, u_textureFactor )).g;
        tex2.g = texture2D(u_texture2, centeredAspectRatio(uv, u_textureFactor )).g;
        
        uv.x -= sin(uv.y) * ratio / 300. * (vel.x + vel.y) / 7.;
        uv.y -= sin(uv.x) * ratio / 300. * (vel.x + vel.y) / 7.;

        tex1.b = texture2D(u_texture, centeredAspectRatio(uv, u_textureFactor )).b;
        tex2.b = texture2D(u_texture2, centeredAspectRatio(uv, u_textureFactor )).b;
        
        


        vec4 fulltex1 = texture2D(u_texture, centeredAspectRatio(vUv, u_textureFactor) );
        vec4 fulltex2 = texture2D(u_texture2, centeredAspectRatio(vUv, u_texture2Factor));
        
        vec4 mixedTextures =  mix(tex1,tex2,u_textureProgress);

        gl_FragColor = mixedTextures;
    }
  </script>

  <script id="post-vertex" type="x-shader/x-vertex">
    uniform float time;
    uniform float progress;
    uniform vec2 resolution;
    varying vec2 vUv;
    uniform sampler2D texture1;

    const float pi = 3.1415925;

    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );
    }
  </script>

  <script id="post-fragment" type="x-shader/x-fragment">
    uniform float time;
    uniform float progress;
    uniform sampler2D tDiffuse;
    uniform vec2 resolution;
    varying vec2 vUv;
    uniform vec2 uMouse;
    uniform float uVelo;
    uniform int uType;


    float circle(vec2 uv, vec2 disc_center, float disc_radius, float border_size) {
      uv -= disc_center;
      uv*=resolution;
      float dist = sqrt(dot(uv, uv));
      return smoothstep(disc_radius+border_size, disc_radius-border_size, dist);
    }

    float map(float value, float min1, float max1, float min2, float max2) {
      return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
    }

    float remap(float value, float inMin, float inMax, float outMin, float outMax) {
      return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);
    }

    float hash12(vec2 p) {
      float h = dot(p,vec2(127.1,311.7));	
      return fract(sin(h)*43758.5453123);
    }

    // #define HASHSCALE3 vec3(.1031, .1030, .0973)
    vec2 hash2d(vec2 p)
    {
      vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));
        p3 += dot(p3, p3.yzx+19.19);
        return fract((p3.xx+p3.yz)*p3.zy);
    }


    void main()	{
      vec2 newUV = vUv;
      vec4 color = vec4(1.,0.,0.,1.);
      
      // colorful
      if(uType==0){
        float c = circle(newUV, uMouse, 0.0, 0.2);
        float r = texture2D(tDiffuse, newUV.xy += c * (uVelo * .5)).x;
        float g = texture2D(tDiffuse, newUV.xy += c * (uVelo * .525)).y;
        float b = texture2D(tDiffuse, newUV.xy += c * (uVelo * .55)).z;
        color = vec4(r, g, b, 1.);
      }

      // zoom
      if(uType==1){
        float c = circle(newUV, uMouse, 0.0, 0.1+uVelo*2.)*40.*uVelo;
        vec2 offsetVector = normalize(uMouse - vUv);
        vec2 warpedUV = mix(vUv, uMouse, c * 0.99); //power
        color = texture2D(tDiffuse,warpedUV) + texture2D(tDiffuse,warpedUV)*vec4(vec3(c),1.);
      }

      // zoom
      if(uType==2){
        float hash = hash12(vUv*10.);
        // float c = -circle(newUV, uMouse, 0.0, 0.1+uVelo*2.)*40.*uVelo;
        // vec2 offsetVector = -normalize(uMouse - vUv);
        // vec2 warpedUV = mix(vUv, uMouse, c * 0.6); //power
        // vec2 warpedUV1 = mix(vUv, uMouse, c * 0.3); //power
        // vec2 warpedUV2 = mix(vUv, uMouse, c * 0.1); //power
        // color = vec4(
        // 	texture2D(tDiffuse,warpedUV ).r,
        // 	texture2D(tDiffuse,warpedUV1 ).g,
        // 	texture2D(tDiffuse,warpedUV2 ).b,
        // 	1.);
        // color = vec4(,0.,0.,1.);
        float c = circle(newUV, uMouse, 0.0, 0.1+uVelo*0.01)*10.*uVelo;
        vec2 offsetVector = normalize(uMouse - vUv);
        // vec2 warpedUV = mix(vUv, uMouse,  20.*hash*c); //power
        vec2 warpedUV = vUv + vec2(hash - 0.5)*c; //power
        color = texture2D(tDiffuse,warpedUV) + texture2D(tDiffuse,warpedUV)*vec4(vec3(c),1.);
      }



      gl_FragColor = color;
    }
  </script>

  <!-- JavaScript -->
  <script src="js/main.js"></script>

</body>

</html>